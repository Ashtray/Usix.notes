<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Usix'Notes]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-01-11T13:39:18.368Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Usix]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Voip语音电话]]></title>
    <link href="http://yoursite.com/2016/01/11/uac-uas/"/>
    <id>http://yoursite.com/2016/01/11/uac-uas/</id>
    <published>2016-01-11T13:10:12.000Z</published>
    <updated>2016-01-11T13:39:18.368Z</updated>
    <content type="html"><![CDATA[<h3 id="Pro"><a href="#Pro" class="headerlink" title="Pro"></a>Pro</h3><p>RFC3261 Voip  (RFC2543 修订)</p>
<blockquote>
<p>SIP协议采用Client/Server模型。<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-每一个请求（Request）触发服务器的一个操作；</span><br><span class="line">-每个操作被称为方法（<span class="function"><span class="keyword">Method</span>）；</span><br><span class="line">-每个请求除了指明具体方法外，还携带了一系列的头域（<span class="title">Header</span> <span class="title">field</span>）,这些头域携带了各种业务信息；</span><br><span class="line">-除了头域外，消息中还可以携带任意类型的消息体（<span class="title">Body</span>），呼叫中最常使用的<span class="title">SDP</span>信息就是通过消息体在<span class="title">Client</span>和<span class="title">Server</span>之间传递的。</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>Server从接收到请求到处理完毕，要回复多个临时响应(Response)，和一个终结响应(Response)，终结响应有且只有一个。<br><a id="more"></a></p>
<hr>
<h3 id="UAC_vs_UAS"><a href="#UAC_vs_UAS" class="headerlink" title="UAC vs UAS"></a>UAC vs UAS</h3><p>请求和他的所有响应构成一个事务<code>（Transaction）</code>，一个完整的呼叫过程包含多个事务，比如呼叫建立和呼叫释放就是两个相互独立的事务。</p>
<blockquote>
<p>用户代理（User Agent）是发起或者接收呼叫的逻辑实体。<br>用户代理客户端-UAC（User Agent Client），用于发起请求；</p>
</blockquote>
<p>用户代理服务器<code>-UAS（User Agent Server）</code>，用于接收请求。<code>UAC/UAS</code>的划分是针对一个事务的。</p>
<p>UA的实际物理形态有：<code>IP Phone，SoftPhone，GateWay......</code><br><code>Proxy Server</code>作为一个网络逻辑实体代理客户端转发请求或者响应；同<code>Proxy Server</code>类似的还有一种设备是<code>B2BUA</code>。<br>blablabla··········<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">好蛋疼的实习题目  终于要做完了  日！！！</span><br></pre></td></tr></table></figure></p>
<p>明天小组作实习汇报，希望不要问我太难的问题~</p>
<p>God bless 么么么哒  ^_^</p>
<hr>
<blockquote>
<p>你们的光合作用  让我更好的生存<br>我的笔 能量 网络 说氧气 食物 阳光<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plants <span class="keyword">for</span> making *oxygen*</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Pro"><a href="#Pro" class="headerlink" title="Pro"></a>Pro</h3><p>RFC3261 Voip  (RFC2543 修订)</p>
<blockquote>
<p>SIP协议采用Client/Server模型。<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-每一个请求（Request）触发服务器的一个操作；</span><br><span class="line">-每个操作被称为方法（<span class="function"><span class="keyword">Method</span>）；</span><br><span class="line">-每个请求除了指明具体方法外，还携带了一系列的头域（<span class="title">Header</span> <span class="title">field</span>）,这些头域携带了各种业务信息；</span><br><span class="line">-除了头域外，消息中还可以携带任意类型的消息体（<span class="title">Body</span>），呼叫中最常使用的<span class="title">SDP</span>信息就是通过消息体在<span class="title">Client</span>和<span class="title">Server</span>之间传递的。</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>Server从接收到请求到处理完毕，要回复多个临时响应(Response)，和一个终结响应(Response)，终结响应有且只有一个。<br>]]>
    
    </summary>
    
      <category term="Ashtray刚" scheme="http://yoursite.com/tags/Ashtray%E5%88%9A/"/>
    
      <category term="RFC3261" scheme="http://yoursite.com/tags/RFC3261/"/>
    
      <category term="UAC" scheme="http://yoursite.com/tags/UAC/"/>
    
      <category term="UAS" scheme="http://yoursite.com/tags/UAS/"/>
    
      <category term="Voip" scheme="http://yoursite.com/tags/Voip/"/>
    
      <category term="proxy" scheme="http://yoursite.com/tags/proxy/"/>
    
      <category term="Ashtray刚" scheme="http://yoursite.com/categories/Ashtray%E5%88%9A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[并发2-Thread和Runnable]]></title>
    <link href="http://yoursite.com/2016/01/11/process-and-thread-2/"/>
    <id>http://yoursite.com/2016/01/11/process-and-thread-2/</id>
    <published>2016-01-11T12:50:12.000Z</published>
    <updated>2016-01-11T12:53:15.911Z</updated>
    <content type="html"><![CDATA[<h2 id="java_xx-class_u53D1_u751F_u4E86_u4EC0_u4E48_uFF1A"><a href="#java_xx-class_u53D1_u751F_u4E86_u4EC0_u4E48_uFF1A" class="headerlink" title="java xx.class发生了什么："></a>java xx.class发生了什么：<br></h2><ul>
<li>编写JVMThread.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMThread</span> </span>&#123;	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>执行java JVMThread 两次</code></p>
<p><code>可以看到任务管理器中(mac-os):</code>  </p>
<blockquote>
<p>501 14810 14798   0  2:44下午 ttys008    0:08.51 java JVMThread</p>
<p>501 14811 14804   0  2:44下午 ttys009    0:02.73 java JVMThread</p>
</blockquote>
<a id="more"></a>
<ul>
<li><p>由此可见，java JVMThread 启动了两个JVM,其中每个JVM运行一个java程序</p>
</li>
<li><p>如果代码中没有创建线程（如上），JVM会启动一个主线程，和其他一系列线程(垃圾回收线程等)</p>
</li>
</ul>
<h2 id="u521B_u5EFA_u7EBF_u7A0B_u7684_u4E24_u79CD_u65B9_u5F0F_uFF1A"><a href="#u521B_u5EFA_u7EBF_u7A0B_u7684_u4E24_u79CD_u65B9_u5F0F_uFF1A" class="headerlink" title="创建线程的两种方式："></a>创建线程的两种方式：</h2><ol>
<li>继承Thread，重写run方法，使用start()使用线程        </li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread&#123;</span><br><span class="line">		     public static void main(String[] args) &#123;</span><br><span class="line">				System.out.println("主线程ID:+ Thread.currentThread().getId());</span><br><span class="line">				TestThread tt = new TestThread("子线程1");</span><br><span class="line">				tt.start();</span><br><span class="line">				TestThread tt2 = new TestThread("子线程2");</span><br><span class="line">				tt2.start();</span><br><span class="line">				TestThread tt3 = new TestThread("子线程2");</span><br><span class="line">				tt3.start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//在此书写线程的执行代码</span></span><br><span class="line">		System.out.println(name + <span class="string">"子线程ID:"</span> + Thread.currentThread().getId());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后，结果为：    </p>
<blockquote>
<p>线程3在线程2之后创建，却更早执行，说明了创建线程并不会阻塞主线程(main)，所有的新建线程都在同一起跑线等待获取CPU等资源</p>
</blockquote>
<ol>
<li>实现Runnable接口，重写run方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"主线程ID:"</span> + Thread.currentThread().getId());</span><br><span class="line">		TestThread run = <span class="keyword">new</span> TestThread();</span><br><span class="line">		Thread t = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">		t.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//	在此书写线程的执行代码</span></span><br><span class="line">		System.out.println(<span class="string">"子线程ID:"</span> + Thread.currentThread().getId());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="java_xx-class_u53D1_u751F_u4E86_u4EC0_u4E48_uFF1A"><a href="#java_xx-class_u53D1_u751F_u4E86_u4EC0_u4E48_uFF1A" class="headerlink" title="java xx.class发生了什么："></a>java xx.class发生了什么：<br /></h2><ul>
<li>编写JVMThread.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMThread</span> </span>&#123;	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>执行java JVMThread 两次</code></p>
<p><code>可以看到任务管理器中(mac-os):</code>  </p>
<blockquote>
<p>501 14810 14798   0  2:44下午 ttys008    0:08.51 java JVMThread</p>
<p>501 14811 14804   0  2:44下午 ttys009    0:02.73 java JVMThread</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Meitu凌" scheme="http://yoursite.com/tags/Meitu%E5%87%8C/"/>
    
      <category term="Runnable" scheme="http://yoursite.com/tags/Runnable/"/>
    
      <category term="process" scheme="http://yoursite.com/tags/process/"/>
    
      <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
      <category term="进程与线程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Meitu凌" scheme="http://yoursite.com/categories/Meitu%E5%87%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[并发1-进程和线程]]></title>
    <link href="http://yoursite.com/2016/01/11/process-and-thread-1/"/>
    <id>http://yoursite.com/2016/01/11/process-and-thread-1/</id>
    <published>2016-01-11T11:12:12.000Z</published>
    <updated>2016-01-11T12:54:41.554Z</updated>
    <content type="html"><![CDATA[<h2 id="u8FDB_u7A0B_u662F_u4EC0_u4E48_uFF1A"><a href="#u8FDB_u7A0B_u662F_u4EC0_u4E48_uFF1A" class="headerlink" title="进程是什么："></a>进程是什么：</h2><ul>
<li><p>计算机最初发明的初衷是用于解决耗时耗力的复杂计算，是一个计算器</p>
</li>
<li><p>最原始的计算机执行程序的过程如下：等待用户输入指令-&gt;用户输入-&gt;计算机操作-&gt;等待用户输入指令-&gt;用户输入-&gt;计算机操作。在用户思考或者输入的过程中,计算机就空闲下来。</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>后来有了批处理系统，用户可以把许多指令(如输入1，输入2)写在磁盘中，计算机的执行过<br>程变为：用户输入指令集合-&gt;取指令-&gt;执行-&gt;取指令-&gt;执行。        </p>
</li>
<li><p>批处理系统大大提高了便捷性，但是还是存在一个问题，假设指令集合中有A,B两个程序，当程序A进行I/O处理时，程序B只能等待程序A直到其运行完。也就是说，内存中只能有一个程序在执行。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>内存举例</th>
<th>程序One</th>
<th>程序Two</th>
<th>计算机中有两个程序</th>
</tr>
</thead>
<tbody>
<tr>
<td>Time1:</td>
<td>内存</td>
<td></td>
<td>内存中装载程序One</td>
</tr>
<tr>
<td>Time2:</td>
<td></td>
<td>内存</td>
<td>内存中装载程序Two</td>
</tr>
</tbody>
</table>
<pre><code>    那么,如何在内存中装入多个程序呢？于是人们发明了进程，每个在运行的程序都看做
一个进程，给每个进程分配合适大小的对应的内存地址空间，进程之间的空间互不扰，并且
保存每个进程的运行状态。通过进程之间的相互切换，使计算机看起来在一段时间内有几个
程序在同时执行。   
</code></pre><table>
<thead>
<tr>
<th>举例</th>
<th>One</th>
<th>Two</th>
<th>计算机中有两个程序</th>
</tr>
</thead>
<tbody>
<tr>
<td>Time1:</td>
<td>部分内存</td>
<td>部分内存</td>
<td>内存中装载程序One,Two,分别在不同的部分。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>进程让程序之间的并发成为了可能，从宏观上看，某个时间段内有多个程序在同时执行，但实际上在某一时刻只有一个程序(一部分的内存)会得到CPU，进行执行。</p>
</blockquote>
<hr>
<h2 id="u7EBF_u7A0B_u662F_u4EC0_u4E48_uFF1A"><a href="#u7EBF_u7A0B_u662F_u4EC0_u4E48_uFF1A" class="headerlink" title="线程是什么："></a>线程是什么：</h2><ul>
<li><p>进程让程序之间的并发成为了可能，我们可以在电脑上同时听歌，打字了(两个不同的程序之间切换)。</p>
</li>
<li><p>但是人们对程序实时性的要求越来越高。比如对QQ音乐来说，它不仅要处理用户所发送的交互请求，还要播放歌曲。假设某一时刻QQ音乐在播放歌曲，你点击了“暂停”按钮，需要等待播放歌曲完毕之后才能处理“暂停”操作，这种程序肯定是不合格的。</p>
</li>
<li><p>于是人们把QQ音乐这个程序所对应的进程拆分成了多个线程，有播放歌曲的线程，处理交互请求的线程，每个线程负责一个独立的子任务，这样的话，我们点击了“暂停”按钮，QQ音乐会释放暂停播放歌曲的线程，让交互请求的线程处理用户的请求，响应完之后再切换回来，让播放歌曲的线程得到CPU。具体过程如下：</p>
<blockquote>
<p>播放线程———————挂起`````````````````播放线程———–      ———-用户点击暂停————–交互线程————处理完毕</p>
</blockquote>
</li>
</ul>
<p>所以说，线程让进程内的子任务并发成为了可能。</p>
<hr>
<h1 id="u7A0B_u5E8F_uFF0C_u8FDB_u7A0B_uFF0C_u7EBF_u7A0B_u4E09_u8005_u4E4B_u95F4_u7684_u5173_u7CFB_uFF1A"><a href="#u7A0B_u5E8F_uFF0C_u8FDB_u7A0B_uFF0C_u7EBF_u7A0B_u4E09_u8005_u4E4B_u95F4_u7684_u5173_u7CFB_uFF1A" class="headerlink" title="程序，进程，线程三者之间的关系："></a>程序，进程，线程三者之间的关系：</h1><ol>
<li><p>程序是我们写的代码，需要对应到一个具体的进程来运行，进程间有独立的内存地址，互不干扰。线程是进程的子任务，属于同一进程的线程共享相同的内存。</p>
</li>
<li><p>进程让程序之间的并发成为了可能，线程让进程内的子任务并发成为了可能。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u8FDB_u7A0B_u662F_u4EC0_u4E48_uFF1A"><a href="#u8FDB_u7A0B_u662F_u4EC0_u4E48_uFF1A" class="headerlink" title="进程是什么："></a>进程是什么：</h2><ul>
<li><p>计算机最初发明的初衷是用于解决耗时耗力的复杂计算，是一个计算器</p>
</li>
<li><p>最原始的计算机执行程序的过程如下：等待用户输入指令-&gt;用户输入-&gt;计算机操作-&gt;等待用户输入指令-&gt;用户输入-&gt;计算机操作。在用户思考或者输入的过程中,计算机就空闲下来。</p>
</li>
</ul>]]>
    
    </summary>
    
      <category term="Meitu凌" scheme="http://yoursite.com/tags/Meitu%E5%87%8C/"/>
    
      <category term="process" scheme="http://yoursite.com/tags/process/"/>
    
      <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
      <category term="进程与线程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Meitu凌" scheme="http://yoursite.com/categories/Meitu%E5%87%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Openstack Barbican]]></title>
    <link href="http://yoursite.com/2016/01/10/BarbicanOverview/"/>
    <id>http://yoursite.com/2016/01/10/BarbicanOverview/</id>
    <published>2016-01-10T12:12:12.000Z</published>
    <updated>2016-01-11T11:53:47.360Z</updated>
    <content type="html"><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>我在OpenStack Barbican项目中学习了1个多月，学到了很多，也做了一些贡献。在此写下总结，算是给自己的学习工作做一个交代。写完就不玩Barbican了。。。</p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>Barbican项目为OpenStack提供了密钥管理，它避免了在应用中硬编码密钥和加密算法，CA认证，还有一些机密数据的存储。</p>
<a id="more"></a>
<h1 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h1><p>Barbican项目从上到下可以分成3层。从上到下看，第一层是API层。跟多数OpenStack项目一样，Barbican项目也是采用Paste构建的REST API。<br>第二层是barbican逻辑控制层，提供一些封装，队列和一些访问控制等，最下面一层是插件层，提供多种多样的插件，提供最为基本的加解密功能。它可以对接软件化的密码算法，也可以对接硬件加密机。<br><a href="http://docs.openstack.org/developer/barbican/contribute/architecture.html" target="_blank" rel="external">官方文档</a></p>
<h1 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h1><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>Barbican的API同样是遵循REST风格，它利用了Paste这个Python库搭建。一下，简单介绍Paste库的使用。<br>首先是配置文件babrican-api-paste.ini</p>
<blockquote>
<p>[composite:main]<br><br>use = egg:Paste#urlmap<br><br>/: barbican_version<br><br>/v1: barbican_api</p>
</blockquote>
<p>这里定义了一个入口，main，然后根据接收到的URI进行具体的dispatch。<br>比如：</p>
<ol>
<li><a href="http://localhost:9311/" target="_blank" rel="external">http://localhost:9311/</a> <br><br>这个请求会被dispatch到/所代表的barbican_version进行处理</li>
<li><a href="http://localhost:9300/v1/containers" target="_blank" rel="external">http://localhost:9300/v1/containers</a><br><br>这个请求会被dispatch到/v1代表的barbican_api进行处理。</li>
</ol>
<blockquote>
<p>[pipeline:barbican_version]<br><br>pipeline = versionapp</p>
</blockquote>
<p>pipeline是一系列middleware的集合，个人理解为hook point，在一个pipeline中可以定义多个hook函数，改变数据流向。<br>如上面的定义，数据将流到versionapp中。</p>
<blockquote>
<p>[app:versionapp]<br><br>paste.app_factory = barbican.api.app:create_version_app</p>
</blockquote>
<p>这里就定义了versionapp所在的位置，所以，当barbican api接收到特定URI时，会执行这个函数。</p>
<p>同理，当/v1这个标志被触发后，会执行预先设定好的函数。但是，这里稍复杂。</p>
<blockquote>
<p>[pipeline:barbican_api]<br><br>pipeline = keystone_authtoken context apiapp</p>
</blockquote>
<p>可见，当babrican接受了/v1的URI后，请求数据会先流到keystone_authtoken,然后context，最后才是apiapp。<br>这里简单展开介绍各个middleware了。keystone_authtoken是keystonemiddleware提供的，用于跟keystone交互的middleware，这样barbican就具备了获取keystone Token的能力。<br>context就是barbican中预先定义的类，用于将keystone Token植入到请求头中。最后才是真正处理请求的apiapp。</p>
<p>经过了这些pipeline，请求终于作用到了具体的类中。<br>处理具体请求的响应函数都在barbican/api/controllers中，如何响应，请参照 <a href="http://pecan.readthedocs.org/en/latest/" target="_blank" rel="external">Pecan</a></p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>其实，Barbican更像是一个agent，从用户中获取请求，并转发给plugin。所以，第二层，Barbican做了一些具体的工作，来协调，监视，审计转发。<br>在这一层中，有很多术语需要厘清。</p>
<ol>
<li>Secret 一份加密档案，可以是文本可以是二进制流。密钥就可以以secret的形式保存。</li>
<li>Container 类似于文件夹（generic），多个secret的集合。</li>
<li>ACL 提供RBAC访问控制。</li>
<li>cas 证书</li>
<li>quota 限定使用量</li>
</ol>
<p>这层的功能实现比较简单，但需要注意几点。</p>
<ol>
<li>Barbican采用sqlalchemy库与数据库交互。这个库很奇怪，以类的形式对应一张表格。<br>比如我想要一张保存secret的表格，那么我就要在secret这个类中，插入特定格式的信息，然后，我每次创建secret这个类的实例，那么表格中<br>就存在了这个条目。<ol>
<li>在与plugin交互的方面，barbican定义了大量的数据结构，常常看的我犯晕。<a href="http://docs.openstack.org/developer/barbican/plugin/secret_store.html" target="_blank" rel="external">数据结构总览</a></li>
</ol>
</li>
<li>文档里是有消息队列(queue(oslo-messaging))来支持多节点并行计算的，不过目前还没有实现。毕竟，Barbican这个项目还不是很成熟。</li>
</ol>
<h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><p>这一层我并没有接触，但是关键的数据结构都在Proxy设定好了，接口什么的都已经预先设置了，按照<a href="http://docs.openstack.org/developer/barbican/plugin/index.html" target="_blank" rel="external">文档</a>实现关键函数就可以了。</p>
<p>Enjoy!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>我在OpenStack Barbican项目中学习了1个多月，学到了很多，也做了一些贡献。在此写下总结，算是给自己的学习工作做一个交代。写完就不玩Barbican了。。。</p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>Barbican项目为OpenStack提供了密钥管理，它避免了在应用中硬编码密钥和加密算法，CA认证，还有一些机密数据的存储。</p>]]>
    
    </summary>
    
      <category term="OpenStack" scheme="http://yoursite.com/tags/OpenStack/"/>
    
      <category term="Opensource" scheme="http://yoursite.com/tags/Opensource/"/>
    
      <category term="nazca汀" scheme="http://yoursite.com/tags/nazca%E6%B1%80/"/>
    
      <category term="nazca汀" scheme="http://yoursite.com/categories/nazca%E6%B1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python爬虫（一）]]></title>
    <link href="http://yoursite.com/2015/12/27/Low-level-web-crawler/"/>
    <id>http://yoursite.com/2015/12/27/Low-level-web-crawler/</id>
    <published>2015-12-27T02:12:12.000Z</published>
    <updated>2015-12-27T12:02:00.671Z</updated>
    <content type="html"><![CDATA[<p>@(BigMax)[Python|Selenium|爬虫]</p>
<hr>
<h3 id="u4E3A_u4EC0_u4E48_u6211_u8981_u722C_u866B_u5462"><a href="#u4E3A_u4EC0_u4E48_u6211_u8981_u722C_u866B_u5462" class="headerlink" title="为什么我要爬虫呢"></a><strong>为什么我要爬虫呢</strong></h3><p>刚开始实习的时候，公司要求要统计一些bug数据，但是录入平台用的TX的平台，没有提供数据查询接口，数据库也不给查，真是sun了dog了。但是领导有需求，作为打工仔（实习廉价打工仔）就要满足老板要求。问了问老师傅怎么搞，“这个简单，爬虫就好了嘛。”。</p>
<h3 id="u5565_u90FD_u4E0D_u4F1A_uFF0C_u600E_u4E48_u722C_u866B_u5462"><a href="#u5565_u90FD_u4E0D_u4F1A_uFF0C_u600E_u4E48_u722C_u866B_u5462" class="headerlink" title="啥都不会，怎么爬虫呢"></a><strong>啥都不会，怎么爬虫呢</strong></h3><p>对于一直作为技术渣的我，知道爬，知道虫，爬虫怎么搞，母鸡。于是开始了BD（CET-6一直不过，不好意思Google。不过对于技术类的Google真好用）。什么urllib2、requests、scrapy……各种入眼，对于Python都是刚入门的人来说，好晕~~~<br>有一个老师傅说了，“用selenium，跟之前用的appium差不多，简单”。查了下，是比较简单，就用这个了。</p>
<h3 id="u597Dlow_u7684_u201C_u722C_u866B_u201D"><a href="#u597Dlow_u7684_u201C_u722C_u866B_u201D" class="headerlink" title="好low的“爬虫”"></a><strong>好low的“爬虫”</strong></h3><p>为什么加引号呢，因为严格来说，这不算我们传统意义上的网络爬虫，或者说爬虫都不算，但是最起码它帮我完成了老板的需求，毕竟也是第一次用Python实现功能，并且这个功能现在一直在用（当然实现方式早就换了）。所以，第一次写博客还是记录一下，这种low的不能再low的“爬虫”。</p>
<a id="more"></a>
<hr>
<h3 id="Selenium_uFF1F"><a href="#Selenium_uFF1F" class="headerlink" title="Selenium？"></a><strong>Selenium？</strong></h3><p>这是个什么？<a href="http://docs.seleniumhq.org/" target="_blank" rel="external">官网</a>是这么说的——Primarily, it is for automating web applications for testing purposes, but is certainly not limited to just that. Selenium是一套Web应用程序测试系统，这也就是我之前一直说这不是严格意义上的爬虫，但是官网都说了——What you do with that power is entirely up to you.那我就用它爬。</p>
<h3 id="Use_It"><a href="#Use_It" class="headerlink" title="Use It"></a><strong>Use It</strong></h3><h4 id="u4E00_u3001_u5B89_u88C5"><a href="#u4E00_u3001_u5B89_u88C5" class="headerlink" title="一、安装"></a><strong>一、安装</strong></h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> selenium</span><br></pre></td></tr></table></figure>
<p>pypi的源在国内用比较痛，所以可以用豆瓣的源来安装，地址:<a href="http://pypi.douban.com/simple/" target="_blank" rel="external">http://pypi.douban.com/simple/</a><br>使用方式：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="operator"><span class="keyword">install</span> -<span class="keyword">i</span> <span class="keyword">http</span>://pypi.douban.com/simple/ selenium <span class="comment">--trusted-host pypi.douban.com</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="u4E8C_u3001_u4F7F_u7528"><a href="#u4E8C_u3001_u4F7F_u7528" class="headerlink" title="二、使用"></a><strong>二、使用</strong></h4><p>要想使用，首先你要告诉程序有这个东西，所以，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br></pre></td></tr></table></figure></p>
<p>第一个包是为了使用webdriver，第二个包是为了使用Keys，用来干什么，接下来会说明。<br>既然selenium是对于Web应用程序的测试系统（当然了这里我们用来“爬虫”），那么就要让这个程序跑起来，在哪里跑呢？废话，浏览器！那么我们就用刚才导入的webdriver包来获取浏览器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser = webdriver.Firefox()</span><br></pre></td></tr></table></figure></p>
<p>这里我用的是Firefox，也可以用Chrome、IE。可能你会问我用的360浏览器，怎么获取相应的browser，这个问题就机智了，如此大神的浏览器，你可以给红衣大炮发个邮件，开发个360driver出来（有点狗血。）对于selenium，目前也就是知道一点皮毛尖儿，好在知乎有懂行的：</p>
<blockquote>
<p>Selenium 2.0包含了两种模式，一种是base在WebDriver上的，通过Java直接操作浏览器，这种方式只支持IE，Firefox，Chrome几种浏览器，当然，WebDriver中用于打开浏览器的代码并不复杂，如果你愿意的话，可以自己基于InternetExplorer来写一个新的360Driver。Selenium 2.0支持的另外一种模式是Selenium Core的JS模式，这种模式下你可以直接打开360浏览器，用360浏览器访问JS写的测试代码。当然，如果你想要通过RC模式启动360浏览器的话，仍然需要自己修改RC Server的代码，自己定一个新的命令参数来支持打开360浏览器。鉴于360的所谓双核浏览器其实只是在IE内核和Chrome内核上的封装，所以其实并没有什么必要专门用Selenium在360浏览器下测试Web应用的功能。    –<a href="http://www.zhihu.com/question/31510772/answer/52503774" target="_blank" rel="external">段念  知乎</a></p>
</blockquote>
<p>言归正传，拿到browser之后就该办正事了，就要输入要访问的url，怎么输入呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser.get(url)</span><br></pre></td></tr></table></figure></p>
<p>如果程序就到这里的话，在命令行里python selenium_test.py，你就可以看到浏览器打开并跳转到了你要访问的界面。如果是做自动化测试的话，可以把browse.title这个东西print一下。</p>
<p>进到要获取数据的界面之后怎么去操作想要操作的控件，或者要得到的数据呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element = browser.find_element_by_id(<span class="string">'username'</span>)</span><br></pre></td></tr></table></figure></p>
<p>此时的element就是页面中的某个控件了，因为我要爬取的数据要先登录，所以这里是获取了用户名输入框。对于页面中没有id的控件我们可以使用find_element_by_name、find_element_by_link_text、find_element_by_xpath等方法来获取相应的控件。</p>
<p>还记在最开始我们导入了两个包吗？第二个包是Keys，现在就要用到了，因为我要登录，所以对于输入框我要填入用户名密码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.send_keys(user_name)</span><br></pre></td></tr></table></figure></p>
<p>现在你就可以看到本该你输入的信息已经在输入框里面了。send_keys这个方法还有个很实用的功能。想象下，当我们输入完用户名密码之后会老老实实的去点击登录按钮吗？现在你也可以不用去find登录按钮，只需要使用send_keys方法就可以了，把Keys.RETURN作为参数传给它，就OK了。PS：如果你有强迫症，非要点击一下的话，element.click()。</p>
<p><strong>这里我要说下这个很LOW的“爬虫”比较方便的地方，就是登陆的处理，或者说对于任何POST的请求方式的处理，你可以不用费劲儿的去研究它到底传了一个什么样的form，甚至去研究登录时的一些验证之类的，因为selenium做的就是你做的。</strong></p>
<p>对于获取的控件怎么获取它对应的数据呢？就可以通过这个控件的属性进行操作了。element.text这样当时就已经满足了我拿到表格里数据的需求了。</p>
<p>for起来，这样要获取的所有项目中的表格里的数据，就一条条的插到了自己的数据库。python操作数据库，还停留在裸写SQL的阶段，看过老师傅的代码后，决定要改进了！以后再总结。</p>
<p>for结束之后就可以关闭刚才程序唤出来的browser了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser.close()</span><br></pre></td></tr></table></figure></p>
<p>至此，数据就LOWLOW的“爬”出来了。</p>
<p>###<strong>讲一下：</strong><br>有些自己踩得坑：</p>
<ul>
<li>因为都是在浏览器里做的，只是本该自己做的让selenium跑了起来，所以响应时间一定要考虑进去，当进行一些请求之后，要告诉程序等一等：time.sleep()。</li>
<li>对于有些时间控件的操作。当时我就当做是普通的输入框进行的操作，每次send_keys把日期赋值进去，然后就可以看到日期填进去了，但是当对其他控件操作的时候，日期框就莫名其妙的空了。很久之前的问题了，当时傻逼了具体因为什么竟然忘了记录下来，现在在stackoverflow上还没有找到当时看的回答。解决方案有两种：<ol>
<li>获取控件之后，先进行清除element.clear()，然后再send_keys()。OK！</li>
<li>不使用send_keys()方式进行赋值，而是使用JS给其赋值（忘了说了，selenium是可以执行JS的）：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js_ex = <span class="string">"document.getElementsByName(elementName)[0].setAttribute('value', '2015-08-31')"</span></span><br><span class="line">browser.execute_script(js_ex)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<p>比较推荐使用第一种方法，python自家能搞定的事情，最好还是不要让外人插手。</p>
<hr>
<p>第一篇博客，有点虎头蛇尾，慢慢搞。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>@(BigMax)[Python|Selenium|爬虫]</p>
<hr>
<h3 id="u4E3A_u4EC0_u4E48_u6211_u8981_u722C_u866B_u5462"><a href="#u4E3A_u4EC0_u4E48_u6211_u8981_u722C_u866B_u5462" class="headerlink" title="为什么我要爬虫呢"></a><strong>为什么我要爬虫呢</strong></h3><p>刚开始实习的时候，公司要求要统计一些bug数据，但是录入平台用的TX的平台，没有提供数据查询接口，数据库也不给查，真是sun了dog了。但是领导有需求，作为打工仔（实习廉价打工仔）就要满足老板要求。问了问老师傅怎么搞，“这个简单，爬虫就好了嘛。”。</p>
<h3 id="u5565_u90FD_u4E0D_u4F1A_uFF0C_u600E_u4E48_u722C_u866B_u5462"><a href="#u5565_u90FD_u4E0D_u4F1A_uFF0C_u600E_u4E48_u722C_u866B_u5462" class="headerlink" title="啥都不会，怎么爬虫呢"></a><strong>啥都不会，怎么爬虫呢</strong></h3><p>对于一直作为技术渣的我，知道爬，知道虫，爬虫怎么搞，母鸡。于是开始了BD（CET-6一直不过，不好意思Google。不过对于技术类的Google真好用）。什么urllib2、requests、scrapy……各种入眼，对于Python都是刚入门的人来说，好晕~~~<br>有一个老师傅说了，“用selenium，跟之前用的appium差不多，简单”。查了下，是比较简单，就用这个了。</p>
<h3 id="u597Dlow_u7684_u201C_u722C_u866B_u201D"><a href="#u597Dlow_u7684_u201C_u722C_u866B_u201D" class="headerlink" title="好low的“爬虫”"></a><strong>好low的“爬虫”</strong></h3><p>为什么加引号呢，因为严格来说，这不算我们传统意义上的网络爬虫，或者说爬虫都不算，但是最起码它帮我完成了老板的需求，毕竟也是第一次用Python实现功能，并且这个功能现在一直在用（当然实现方式早就换了）。所以，第一次写博客还是记录一下，这种low的不能再low的“爬虫”。</p>]]>
    
    </summary>
    
      <category term="BigMax" scheme="http://yoursite.com/tags/BigMax/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Selenium" scheme="http://yoursite.com/tags/Selenium/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="BigMax" scheme="http://yoursite.com/categories/BigMax/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenStack开源社区开发指南]]></title>
    <link href="http://yoursite.com/2015/12/26/tips-on-contributing-to-openstack-source-community/"/>
    <id>http://yoursite.com/2015/12/26/tips-on-contributing-to-openstack-source-community/</id>
    <published>2015-12-26T02:12:12.000Z</published>
    <updated>2015-12-26T06:59:14.400Z</updated>
    <content type="html"><![CDATA[<p>OpenStack开源社区开发指南 </p>
<p><a href="http://www.openstack.org/" title="OpenStack" target="_blank" rel="external">Openstack</a></p>
<h2 id="u8D21_u732E_u65B9_u5F0F"><a href="#u8D21_u732E_u65B9_u5F0F" class="headerlink" title="贡献方式"></a>贡献方式</h2><ol>
<li>BP(BluePrint)<br><br> 如果你要新增一项特性，那么你首先需要撰写一个BP，写明为什么你要这么做，怎么做，以及后果。一旦这个BP被通过了，你就可以按照自己的意愿开始干活了。</li>
<li>Fix bug<br><br> <a href="https://bugs.launchpad.net/项目名" target="_blank" rel="external">https://bugs.launchpad.net/项目名</a> 这个页面中会显示特定项目的bug列表。你可以从中选择bug进行修复。</li>
<li>Review <br><br> 在gerrit中，会显示很多其他人提交的patch，你可以review他人的代码并且给出评分。一般用户最多只能+1分，core review成员有+2分的能力。 一个patch能否被用过，决定于是否达到2个+2分的review。当然，如果你觉得他人的代码写的不够，做法有些妥当，那么-1分也是可以的。</li>
</ol>
<a id="more"></a>
<h2 id="u4E0E_u793E_u533A_u4FDD_u6301_u8054_u7CFB"><a href="#u4E0E_u793E_u533A_u4FDD_u6301_u8054_u7CFB" class="headerlink" title="与社区保持联系"></a>与社区保持联系</h2><ol>
<li>IRC<br><br>IRC是常用的即时聊天工具。OpenStack使用freenode进行通信。建议下载Xchat，连接freenode，然后就可以加入任何一个channel。 一般来说都是 openstack-项目名 例如openstack-nova就是nova项目的讨论组。</li>
<li>Meeting<br><br>OpenStack各个项目都有属于自己的每周例会，在特定的频道中进行会议。一般是openstack-meeting-alt. 如果你有什么议题，可以在所在项目的wiki页面上的meeting agenda中添加，会议上会逐项审议，就可以讨论到你的议题了。比如，你写了一个BP，那么可能需要你在会议中提出来，由大家进行讨论，根据反馈结果进行修改，这样BP被通过的概率就会大大提高了。</li>
</ol>
<h2 id="u63D0_u4EA4PATCH"><a href="#u63D0_u4EA4PATCH" class="headerlink" title="提交PATCH"></a>提交PATCH</h2><ol>
<li>注意commit信息<br><br> commit信息的写法很有讲究。一般是第一行写概要，指出这个patch做了什么，然后空2行写具体内容。最后，如果是实现一个bp，那么需要在commit信息中加上Implements: blueprint bp名称 。 这样一旦这个patch被merge了， 那么你所提出的bp就会被系统自动标注为已经实现。</li>
<li>git-review<br><br> 所有的code review都是在gerrit平台上进行的。所以，我们要先配置好git-review才可以向平台提交patch。</li>
</ol>
<h2 id="OpenStack_u4EE3_u7801_u901A_u7528_u5E93"><a href="#OpenStack_u4EE3_u7801_u901A_u7528_u5E93" class="headerlink" title="OpenStack代码通用库"></a>OpenStack代码通用库</h2><ol>
<li>Spinx<br><br> 这是一个文档生成工具，可以根据RST文档，自动生成HTML。Opentack大量使用了这个module.</li>
<li>Pbr<br><br> 这是用于替代pathon setupuptools的 module。提供更加强大的功能：<ul>
<li>自动整合spinx进行文档处理</li>
<li>自动安装dependency，只需要我们在requirements.txt中写上module的名字和版本号。</li>
<li>在git中自动产生AUTHORS和ChangeLog</li>
<li>与git整合<br>当然，Openstack采用它作为安装工具。</li>
</ul>
</li>
<li>tox<br><br>tox是一个测试工具，你只需要写好测试用例，配置好tox（tox.ini）然后运行tox就好了。它会自动安装测试过程中需要的包，并且它是运行在干净的虚拟环境中。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>OpenStack开源社区开发指南 </p>
<p><a href="http://www.openstack.org/" title="OpenStack">Openstack</a></p>
<h2 id="u8D21_u732E_u65B9_u5F0F"><a href="#u8D21_u732E_u65B9_u5F0F" class="headerlink" title="贡献方式"></a>贡献方式</h2><ol>
<li>BP(BluePrint)<br><br> 如果你要新增一项特性，那么你首先需要撰写一个BP，写明为什么你要这么做，怎么做，以及后果。一旦这个BP被通过了，你就可以按照自己的意愿开始干活了。</li>
<li>Fix bug<br><br> <a href="https://bugs.launchpad.net/项目名">https://bugs.launchpad.net/项目名</a> 这个页面中会显示特定项目的bug列表。你可以从中选择bug进行修复。</li>
<li>Review <br><br> 在gerrit中，会显示很多其他人提交的patch，你可以review他人的代码并且给出评分。一般用户最多只能+1分，core review成员有+2分的能力。 一个patch能否被用过，决定于是否达到2个+2分的review。当然，如果你觉得他人的代码写的不够，做法有些妥当，那么-1分也是可以的。</li>
</ol>]]>
    
    </summary>
    
      <category term="OpenStack" scheme="http://yoursite.com/tags/OpenStack/"/>
    
      <category term="Opensource" scheme="http://yoursite.com/tags/Opensource/"/>
    
      <category term="nazca汀" scheme="http://yoursite.com/tags/nazca%E6%B1%80/"/>
    
      <category term="nazca汀" scheme="http://yoursite.com/categories/nazca%E6%B1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[主流浏览器配置PAC文件]]></title>
    <link href="http://yoursite.com/2015/12/19/navigetor-pac/"/>
    <id>http://yoursite.com/2015/12/19/navigetor-pac/</id>
    <published>2015-12-19T02:12:12.000Z</published>
    <updated>2015-12-27T12:03:35.122Z</updated>
    <content type="html"><![CDATA[<h1 id="u4E3B_u6D41_u6D4F_u89C8_u5668_u914D_u7F6EPAC_u6587_u4EF6"><a href="#u4E3B_u6D41_u6D4F_u89C8_u5668_u914D_u7F6EPAC_u6587_u4EF6" class="headerlink" title="主流浏览器配置PAC文件"></a>主流浏览器配置PAC文件</h1><h2 id="5E__5E"><a href="#5E__5E" class="headerlink" title="^_^"></a>^_^</h2><h3 id="0x00__u4EC0_u4E48_u662FPAC_u6587_u4EF6"><a href="#0x00__u4EC0_u4E48_u662FPAC_u6587_u4EF6" class="headerlink" title="0x00 什么是PAC文件"></a>0x00 什么是PAC文件</h3><p>PAC (<code>Proxy Auto Config</code>) 是一个 <code>Script</code>；经由编写这个 <code>Script</code>，我们可以让系统判断在怎么样的情形下，要利用哪一台 <code>Proxy</code> 来进行联机。    </p>
<blockquote>
<p>那么，我们所用得<code>Proxy.pac</code>文件的本质是<code>javascript</code>的一个函数，通过设定各种条件（域名，IP等等），从而让浏览器加载的时候自动去寻找对应的代理服务器。</p>
</blockquote>
<p>@(eg:)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindProxyForURL</span>(<span class="params">url, host</span>) </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(isInNet(myIpAddress(), <span class="string">"10.71.80.0"</span>, <span class="string">"255.255.255.0"</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span><span class="string">"PROXY 112.186.227.85:8080"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span><span class="string">"DIRECT"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>当浏览器加载这个<code>proxy.pac</code>文件之后，就会自动比较自己的IP地址，如果属于<code>10.71.80.0/24</code>这个范围，那么他就使用代理服务器<code>112.186.227.85:8080</code>，否则直接连接网络。</p>
<blockquote>
<p>当然，想要科学上网的怎么会这么简单呢，那么这里有福利下载代理文件</p>
</blockquote>
<p>以下文件是同学的研究生毕设，基于SOCKET5通讯，撞墙概率小，不会受到污染，望小范围传播 ##^_^##</p>
<p><a href="http://hitwhtest.oss-cn-beijing.aliyuncs.com/hitwh.pac" target="_blank" rel="external">戳我戳我 -&gt;配置文件下载</a></p>
<hr>
<h2 id="u51E0_u6B3E_u6D4F_u89C8_u5668_u914D_u7F6EPAC_u6587_u4EF6"><a href="#u51E0_u6B3E_u6D4F_u89C8_u5668_u914D_u7F6EPAC_u6587_u4EF6" class="headerlink" title="几款浏览器配置PAC文件"></a>几款浏览器配置PAC文件</h2><h3 id="0x01_IE_u6D4F_u89C8_u5668_uFF08IE11_u9664_u5916_uFF09"><a href="#0x01_IE_u6D4F_u89C8_u5668_uFF08IE11_u9664_u5916_uFF09" class="headerlink" title="0x01 IE浏览器（IE11除外）"></a>0x01 IE浏览器（IE11除外）</h3><p>打开IE可以在选项（Option）-&gt;连接(Connection)-&gt;局域网设置（LAN setting） 中进行设置。（IE 11 禁用了本地PAC 解决方法在最后）</p>
<p><img src="http://img1.51cto.com/attachment/201306/134106990.png" alt="setting"></p>
<blockquote>
<p>注意格式是</p>
</blockquote>
<pre><code>file://（文件路径）/proxy.pac
</code></pre><blockquote>
<p>与windows的路径<code>\</code>不一样 用<code>/</code>划分文件夹</p>
</blockquote>
<p><img src="http://img1.51cto.com/attachment/201306/134108267.png" alt="enter image description here"></p>
<p>这样就设置好了</p>
<hr>
<h3 id="0x02_Chrome/Chromium_u6D4F_u89C8_u5668_u8BBE_u7F6E"><a href="#0x02_Chrome/Chromium_u6D4F_u89C8_u5668_u8BBE_u7F6E" class="headerlink" title="0x02  Chrome/Chromium浏览器设置"></a>0x02  Chrome/Chromium浏览器设置</h3><blockquote>
<p><code>Chrome/Chromium</code>本身就是直接调用IE的代理设置，你可以直接在IE里设置，或者如下设置<br>Windows 上最新版本Chrome 46.0.2490.86 m  设置：<br>点击右上角的  三道杠-&gt;设置,拖到底部，点击“显示高级设置”，找到“网络”下边“更改代理服务器设置” 弹出上面的图一，就是IE浏览器的设置了，参考上面。</p>
</blockquote>
<p>版本较老的设置如下：</p>
<blockquote>
<p>点击浏览器右上角的扳手图标，选择“选项“-”高级选项“-”更改代理设置“，接下来Chrome会自动打开IE的代理设置窗口，设置方法可参考IE浏览器设置。</p>
</blockquote>
<hr>
<h3 id="0x03_Opera_u6D4F_u89C8_u5668_u8BBE_u7F6E"><a href="#0x03_Opera_u6D4F_u89C8_u5668_u8BBE_u7F6E" class="headerlink" title="0x03 Opera浏览器设置"></a>0x03 Opera浏览器设置</h3><blockquote>
<p>点击“工具“-”首选项“-”高级“-”网络“-”代理服务器“，最下方“使用自动代理服务器配置”在这里填入PAC文件的位置就可以利用PAC中设置的规则上网了。</p>
</blockquote>
<pre><code>PAC的路径格式和IE一样
</code></pre><hr>
<h3 id="0x04__u706B_u72D0_28Firefox_29_u6D4F_u89C8_u5668_u8BBE_u7F6E"><a href="#0x04__u706B_u72D0_28Firefox_29_u6D4F_u89C8_u5668_u8BBE_u7F6E" class="headerlink" title="0x04 火狐(Firefox)浏览器设置"></a>0x04 火狐(Firefox)浏览器设置</h3><blockquote>
<p>打开火狐（Firefix）浏览器，点击右上角的“打开菜单”-&gt;“选项”；<br>切换到“高级”选项卡；<br>选择“网络” ；<br>点击“设置”按钮。<br>选择“自动代理配置（PAC）”；<br>填写pac文件在您电脑中的地址；<br>点击“确定”按钮；</p>
</blockquote>
<hr>
<h3 id="0x05_IE_u5185_u6838_u7684_u6D4F_u89C8_u5668"><a href="#0x05_IE_u5185_u6838_u7684_u6D4F_u89C8_u5668" class="headerlink" title="0x05  IE内核的浏览器"></a>0x05  IE内核的浏览器</h3><blockquote>
<p>世界之窗（The World）<br>傲游浏览器（Maxthon）<br>腾讯TT（Tencent Traveler）<br>爱帆浏览器（Avant Browser）<br>360安全浏览器（360SE）<br>搜狗浏览器（兼容模式）（Sougou Explorer）<br>瑞影浏览器（Rayying）</p>
</blockquote>
<p>以上浏览器都是IE内核的浏览器，按照0x01配置好IE浏览器，就能够使用了</p>
<h3 id="0x06_IE11__u89E3_u51B3_u529E_u6CD5"><a href="#0x06_IE11__u89E3_u51B3_u529E_u6CD5" class="headerlink" title="0x06 IE11 解决办法"></a>0x06 IE11 解决办法</h3><p>说一下ie11以及在win8.1下需要注意的路径、模式和安全问题。</p>
<ul>
<li><p>路径问题：ie11不支持使用本地pac文件了，得用http或者https方式载入pac。非要用本地pac文件的话，可以通过修改注册表来实现。</p>
<p>   [HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings]<br>   “EnableLegacyAutoProxyFeatures”=dword:00000001<br>增加这项后就行了，如上图，注意不是反斜杠\ 网上很多东西都是对win8.1以前的系统适用的，要想正常使用就得用斜杠// 例如<code>file://c:/my.pac</code></p>
<p>可以参考 <a href="http://blogs.msdn.com/b/ieinternals/archive/2013/10/11/web-proxy-configuration-and-ie11-changes.aspx" target="_blank" rel="external">MSDN的说明</a></p>
</li>
<li>模式问题：IE11不支持SOCKS5了。这也是搞了半天才弄清楚的。虽然lan设置-高级里面有“套接字（SOCKS）”的选项，但不知道是不是指低版本的SOCKS，反正IE11是不能直接在PAC里面用SOCKS5的，需要先自己转成http或https模式。</li>
<li>安全问题：用了PAC后所有返回‘DIRECT’的网站都会在‘本地Intranet’安全区。这个区域的安全性一般是很低的，注意把‘保护模式’点上，安全性调高，并且在‘站点’中点掉箭头所指的选项。如果不管它的话IE11会降级成IE7甚至IE5模式。</li>
</ul>
<blockquote>
<p>上面的那篇MSDN blog上 EricLaw 的文章讲得很详细。他一直在说不推荐用本地PAC文件，提供EnableLegacyAutoProxyFeatures只是暂时的，基于 File:// 的已经被弃用了，新的通过http和https方式来加载pac更好。我不太明白，为什么通过http和https来加载pac比通过File:// 好？仅仅是为了路径斜杠和反斜杠统一吗？其实我觉得通过http和https也是有很大风险的，如果黑客修改了你的pac文件，对敏感网站添加一个新的规则，替换掉你的服务器地址，你的敏感信息就可能被截获了跑到他的服务器上。</p>
</blockquote>
<pre><code>[说明：我用的系统是Win7 并没升级到 IE11 所以以上解决办法来自网络]
</code></pre><hr>
<blockquote>
<p>注意：配置好代理后，需要<strong>重启浏览器</strong>使之生效！<br>注意：代理文件修改后，需要<strong>重新载入</strong>才会生效！</p>
</blockquote>
<hr>
<blockquote>
<p>你们的光合作用  让我更好的生存<br>我的笔 能量 网络 说氧气 食物 阳光</p>
</blockquote>
<pre><code>plants for making oxygen
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u4E3B_u6D41_u6D4F_u89C8_u5668_u914D_u7F6EPAC_u6587_u4EF6"><a href="#u4E3B_u6D41_u6D4F_u89C8_u5668_u914D_u7F6EPAC_u6587_u4EF6" class="headerlink" title="主流浏览器配置PAC文件"></a>主流浏览器配置PAC文件</h1><h2 id="5E__5E"><a href="#5E__5E" class="headerlink" title="^_^"></a>^_^</h2><h3 id="0x00__u4EC0_u4E48_u662FPAC_u6587_u4EF6"><a href="#0x00__u4EC0_u4E48_u662FPAC_u6587_u4EF6" class="headerlink" title="0x00 什么是PAC文件"></a>0x00 什么是PAC文件</h3><p>PAC (<code>Proxy Auto Config</code>) 是一个 <code>Script</code>；经由编写这个 <code>Script</code>，我们可以让系统判断在怎么样的情形下，要利用哪一台 <code>Proxy</code> 来进行联机。    </p>
<blockquote>
<p>那么，我们所用得<code>Proxy.pac</code>文件的本质是<code>javascript</code>的一个函数，通过设定各种条件（域名，IP等等），从而让浏览器加载的时候自动去寻找对应的代理服务器。</p>
</blockquote>
<p>@(eg:)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindProxyForURL</span>(<span class="params">url, host</span>) </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(isInNet(myIpAddress(), <span class="string">"10.71.80.0"</span>, <span class="string">"255.255.255.0"</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span><span class="string">"PROXY 112.186.227.85:8080"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span><span class="string">"DIRECT"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Ashtray刚" scheme="http://yoursite.com/tags/Ashtray%E5%88%9A/"/>
    
      <category term="facebook" scheme="http://yoursite.com/tags/facebook/"/>
    
      <category term="proxy" scheme="http://yoursite.com/tags/proxy/"/>
    
      <category term="script" scheme="http://yoursite.com/tags/script/"/>
    
      <category term="翻墙" scheme="http://yoursite.com/tags/%E7%BF%BB%E5%A2%99/"/>
    
      <category term="Ashtray刚" scheme="http://yoursite.com/categories/Ashtray%E5%88%9A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C中文本与二进制方式]]></title>
    <link href="http://yoursite.com/2015/11/11/N-file-open/"/>
    <id>http://yoursite.com/2015/11/11/N-file-open/</id>
    <published>2015-11-11T10:44:12.000Z</published>
    <updated>2016-01-11T13:36:02.704Z</updated>
    <content type="html"><![CDATA[<h3 id="u672C_u8D28"><a href="#u672C_u8D28" class="headerlink" title="本质"></a>本质</h3><p>我们都知道计算机的存储在物理上是二进制的，所以文本文件与二进制文件的区别并不是物理上的，而是</p>
<pre><code>***逻辑上的***
</code></pre><blockquote>
<p>这两者只是在编码层次上有差异。</p>
</blockquote>
<p>简单来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据具体应用，指定某个值是什么意思（这样一个过程，可以看作是自定义编码）</p>
<a id="more"></a>
<blockquote>
<p>从上面可以看出文本文件基本上是定长编码的(也有非定长的编码如UTF-8)，基于字符嘛，每个字符在具体编码中是固定的，ASCII码是8个比特的编码，UNICODE一般占16个比特。而二进制文件可看成是变长编码的，因为是值编码嘛，多少个比特代表一个值，完全由你决定。</p>
</blockquote>
<p>应该说Ｃ的文本读写与二进制的读写是一个编程层次上的问题，与具体的操作系统有关，所以＂用文本方式读写的文件一定是文本文件，用二进制读写的文件一定是二进制文件”这类观点是错误的．下面的讲述非明确指出操作系统类型，都暗指windows．Ｃ的文本方读写与二进制读写的差别仅仅体现在回车换行符的处理上．文本方式写时，每遇到一个</p>
<pre><code>&apos;&apos;\n&apos;&apos;(0AH换行符)
</code></pre><p>它将其换成</p>
<pre><code>&apos;&apos;\r\n&apos;&apos;(0D0AH，回车换行)
</code></pre><p>然后再写入文件；当文本读取时，它每遇到一个’’\r\n’’将其反变化为’’\n’’，然后送到读缓冲区．正因为文本方式有<code>&#39;&#39;\n&#39;&#39;－－&#39;&#39;\r\n&#39;&#39;</code>之间的转换，其存在转换耗时．二进制读写时，其不存在任何转换，直接将写缓冲区中数据写入文件．总地来说，从编程的角度来说，Ｃ中文本或二进制读写都是缓冲区与文件中二进制流的交互，只是文本读写时有回车换行的转换．所以当写缓冲区中无换行符<code>&#39;&#39;\n&#39;&#39;(0AH)</code>，文本写与二进制写的结果是一样的，同理，当文件中不存在<code>&#39;&#39;\r\n&#39;&#39;(0DH0AH)</code>时，文本读与二进制读的结果一样。</p>
<p>对于内容为<code>“Ab123\r\n&quot;</code> 二进制（转化为16进制）码为<code>(41 62 31 32 33 0D 0A)</code>的文件,</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pf1 = fopen(<span class="string">"f:\\1.txt"</span>,<span class="string">"r"</span>);<span class="comment">//或者</span></span><br><span class="line">pf1 = fopen(<span class="string">"f:\\1.txt"</span>,<span class="string">"rb"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">   fread(&amp;a[i],<span class="number">1</span>,<span class="number">1</span>,pf1);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%0X "</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line">fclose(pf1);<span class="comment">//关闭文件</span></span><br></pre></td></tr></table></figure>
<p>的结果分别为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">41</span> <span class="number">62</span> <span class="number">31</span> <span class="number">32</span> <span class="number">33</span> <span class="number">0</span>A   </span><br><span class="line"><span class="number">41</span> <span class="number">62</span> <span class="number">31</span> <span class="number">32</span> <span class="number">33</span> <span class="number">0</span>D  <span class="number">0</span>A</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>5678的存储形式为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASCII码：   　<span class="number">00110101</span>   <span class="number">00110110</span>   <span class="number">00110111</span>   <span class="number">00111000</span>  （四个字节）</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>5678的存储形式为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二进制：      </span><br><span class="line"><span class="number">00010110</span>   <span class="number">00101110</span>  （两个字节）</span><br></pre></td></tr></table></figure></p>
<p>二进制文件和文本文件的唯一差异就是前者含有一些非标准输出的ASCII码。0x01就是非标准输出的ASCII码，</p>
<p>0x61就是标准输出的ASCII码。</p>
<hr>
<blockquote>
<p>你们的光合作用  让我更好的生存<br>我的笔 能量 网络 说氧气 食物 阳光<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plants <span class="keyword">for</span> making oxygen</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u672C_u8D28"><a href="#u672C_u8D28" class="headerlink" title="本质"></a>本质</h3><p>我们都知道计算机的存储在物理上是二进制的，所以文本文件与二进制文件的区别并不是物理上的，而是</p>
<pre><code>***逻辑上的***
</code></pre><blockquote>
<p>这两者只是在编码层次上有差异。</p>
</blockquote>
<p>简单来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。二进制文件是基于值编码的文件，你可以根据具体应用，指定某个值是什么意思（这样一个过程，可以看作是自定义编码）</p>]]>
    
    </summary>
    
      <category term="Ashtray刚" scheme="http://yoursite.com/tags/Ashtray%E5%88%9A/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="\r\n" scheme="http://yoursite.com/tags/r-n/"/>
    
      <category term="fileopen" scheme="http://yoursite.com/tags/fileopen/"/>
    
      <category term="Ashtray刚" scheme="http://yoursite.com/categories/Ashtray%E5%88%9A/"/>
    
  </entry>
  
</feed>
